// Simple De Bruijn assembler (Eulerian path) - C++
// Usage: ./assembler reads.fastq k out.fa
// Builds de Bruijn graph with (k-1)-mers as nodes and finds Eulerian trails
// using Hierholzer's algorithm. Produces contigs in FASTA format.

#include <bits/stdc++.h>
using namespace std;

static void usage(const char* prog) {
	cerr << "Usage: " << prog << " reads.fastq k out.fa\n";
	cerr << "k should be >= 2 (k-mer length).\n";
}

vector<string> read_fastq_seqs(const string &path) {
	ifstream in(path);
	if (!in) throw runtime_error("Cannot open file: " + path);
	vector<string> seqs;
	string line;
	while (getline(in, line)) {
		if (line.empty()) continue;
		if (line[0] == '@') {
			// header
			if (!getline(in, line)) break; // sequence line
			seqs.push_back(line);
			// skip + and quality lines
			getline(in, line);
			getline(in, line);
		} else {
			// tolerate FASTA-like entries (just sequences)
			seqs.push_back(line);
		}
	}
	return seqs;
}

int main(int argc, char** argv) {
	if (argc < 4) { usage(argv[0]); return 1; }
	string reads = argv[1];
	int k = stoi(argv[2]);
	string outfa = argv[3];
	if (k < 2) { cerr << "k must be >= 2\n"; return 1; }

	vector<string> seqs;
	try { seqs = read_fastq_seqs(reads); }
	catch (exception &e) { cerr << e.what() << "\n"; return 1; }

	unordered_map<string, vector<string>> adj; // multiedges stored by duplicates
	unordered_map<string, vector<string>> rev_adj; // reverse adjacency (predecessors)
	unordered_map<string, int> outdeg, indeg;

	int added_edges = 0;
	for (const string &s: seqs) {
		if ((int)s.size() < k) continue;
		for (size_t i = 0; i + (size_t)k <= s.size(); ++i) {
			string kmer = s.substr(i, k);
			string left = kmer.substr(0, k-1);
			string right = kmer.substr(1, k-1);
			adj[left].push_back(right);
			outdeg[left]++;
			indeg[right]++;
			// ensure nodes exist in maps and populate reverse adjacency
			if (!adj.count(right)) adj[right] = vector<string>();
			rev_adj[right].push_back(left);
			if (!rev_adj.count(left)) rev_adj[left] = vector<string>();
			added_edges++;
		}
	}

	if (added_edges == 0) { cerr << "No edges (no k-mers). Try smaller k.\n"; return 1; }

	// choose start node for Eulerian path
	string start = "";
	int start_candidates = 0, end_candidates = 0;
	for (auto &p: adj) {
		const string &node = p.first;
		int out = outdeg[node];
		int in = indeg[node];
		if (out - in == 1) { start = node; start_candidates++; }
		else if (in - out == 1) { end_candidates++; }
	}
	if (start.empty()) {
		// pick any node with outgoing edges
		for (auto &p: adj) if (!p.second.empty()) { start = p.first; break; }
	}


	// Hierholzer's algorithm per connected component: produce contigs
	vector<string> contigs;

	// Copy adjacency lists to a modifiable structure (we pop back)
	unordered_map<string, vector<string>> adj_copy = adj;

	// Find all nodes with outgoing edges
	vector<string> nodes_with_out;
	for (auto &p: adj_copy) if (!p.second.empty()) nodes_with_out.push_back(p.first);

	unordered_set<string> used_start;
	for (const string &node0 : nodes_with_out) {
		// if no edges remain from this node, skip
		if (adj_copy[node0].empty()) continue;

		// pick start for component: prefer node with out-in == 1 if present
		string s = node0;
		// scan component briefly: find a node in same comp with out-in==1
		// We'll do a small BFS of reachable nodes (forward/back) to search for such a node
		queue<string> q;
		unordered_set<string> comp;
		q.push(node0); comp.insert(node0);
		while (!q.empty()) {
			string v = q.front(); q.pop();
			for (const string &w: adj_copy[v]) if (!comp.count(w)) { comp.insert(w); q.push(w); }
			for (const string &w: rev_adj[v]) if (!comp.count(w)) { comp.insert(w); q.push(w); }
		}
		for (const string &cnode: comp) {
			int out = outdeg[cnode]; int in = indeg[cnode];
			if (out - in == 1) { s = cnode; break; }
		}

		// Hierholzer starting from s
		vector<string> stack;
		vector<string> path; // circuit (reversed)
		stack.push_back(s);
		while (!stack.empty()) {
			string v = stack.back();
			if (!adj_copy[v].empty()) {
				string u = adj_copy[v].back();
				adj_copy[v].pop_back();
				stack.push_back(u);
			} else {
				// backtrack
				path.push_back(v);
				stack.pop_back();
			}
		}

		if (path.size() <= 1) continue;
		// path is nodes in reverse order
		reverse(path.begin(), path.end());
		// reconstruct contig: first node (k-1 mer) + last char of each following node
		string contig = path[0];
		for (size_t i = 1; i < path.size(); ++i) contig.push_back(path[i].back());
		contigs.push_back(contig);
	}

	// write contigs to FASTA
	ofstream out(outfa);
	if (!out) { cerr << "Cannot open output: " << outfa << "\n"; return 1; }
	for (size_t i = 0; i < contigs.size(); ++i) {
		out << ">contig_" << (i+1) << " length=" << contigs[i].size() << "\n";
		out << contigs[i] << "\n";
	}

	cerr << "Wrote " << contigs.size() << " contigs to " << outfa << "\n";
	return 0;
}
